/**
 *  Simple implementation of IndexedDB API to read / write time entries.
 */

// TODO: This should be a module, and not a class.
function Database(name, callback) {
  // Yay for ES6 constants!
  const VERSION = 1;

  var db = null;
  var that = this;
  // CHECKME: Probably best in an init() method?
  var request = window.indexedDB.open(name, VERSION);

  request.onerror = function(event) {
    alert("Database could not be created or opened.");
  };

  request.onsuccess = function(event) {
    that.db = event.target.result;
    callback();
  }

  request.onupgradeneeded = function(event) {
    that.db = event.target.result;

    // CHECKME: How would I need to check current version to find out what
    // needs adding on each db version?
    var objectStore = that.db.createObjectStore("time_entry", { keyPath: 'time_entry_id' , autoIncrement: true });
    objectStore.createIndex('date', 'date');

    objectStore.transaction.oncomplete = function(event) {
      console.log("'time_entry' object store created successfully.");
    }
  }

}

Database.prototype.createTimeEntry = function(timeEntry, callback) {
  var timeEntryStore = this.db.transaction("time_entry", "readwrite").objectStore("time_entry");
  var request = timeEntryStore.add(timeEntry);
  request.onsuccess = function(event) {
    // event.target.result contains the time_entry_id generated by the DB.
    callback(event.target.result);
  }
}

Database.prototype.updateTimeEntry = function(timeEntry, callback) {
  var timeEntryStore = this.db.transaction("time_entry", "readwrite").objectStore("time_entry");
  var request = timeEntryStore.put(timeEntry);
  request.onsuccess = function(event) {
    // event.target.result has the time_entry_id.
    // console.log("Time Entry state updated. ID: " + event.target.result);
    if (callback) {
      callback(true);
    }
  };
  request.onerror = function(event) {
    console.log("Error updating Time Entry state. ID: " + event.target.result);
    callback(false);
  }
};

Database.prototype.deleteTimeEntry = function(timeEntryId, callback) {
  var timeEntryStore = this.db.transaction("time_entry", "readwrite").objectStore("time_entry");
  var request = timeEntryStore.delete(timeEntryId);
  request.onsuccess = function(event) {
    console.log("Successfully removed Time Entry. ID: " + timeEntryId);
    if (callback) {
      callback(true);
    }
  };
  request.onerror = function(event) {
    console.log("Error removing Time Entry. ID: " + timeEntryId);
    if (callback) {
      callback(false);
    }
  }
};

// Returns all the existing time entries in the database.
Database.prototype.getAllTimeEntries = function(callback) {
  var timeEntries = [];
  var timeEntryStore = this.db.transaction("time_entry", "readonly").objectStore("time_entry");
  timeEntryStore.openCursor().onsuccess = function(event) {
    var cursor = event.target.result;

    if (cursor) {
      timeEntries.push(cursor.value);
      cursor.continue();
    }
    else {
      callback(timeEntries);
    }
  }
};

// Returns all the existing time entries in the database.
Database.prototype.getAllTimeEntriesSortedByDate = function(callback) {
  var timeEntries = [];
  var timeEntryStore = this.db.transaction("time_entry", "readonly").objectStore("time_entry");
  var index = timeEntryStore.index("date");

  index.openCursor(null, 'prev').onsuccess = function(event) {
    var cursor = event.target.result;

    if (cursor) {
      timeEntries.push(cursor.value);
      cursor.continue();
    }
    else {
      callback(timeEntries);
    }
  }
};