/**
 *  Simple implementation of IndexedDB API to read / write time entries.
 */

// TODO: This should be a module, and not a class.
// IDEA: Could do with allowing methods to pass a class name, so that all "read"
// methods return an object of the relevant class when loading items, a la ORM.
function Database(name, callback) {

  var db_name = name;
  var request = null;
  var db = null;
  var that = this;

  // Yay for ES6 constants!
  const VERSION = 1;

  function dbErrorHandler(event) {
    // TODO: Add console.log entry with some actual useful info.
    // Also, return false?.
    alert("Database error: " + event.target.errorCode);
  }

  // CHECKME: Probably best in an init() method?
  var request = window.indexedDB.open(db_name, VERSION);

  request.onerror = function(event) {
    alert("Database could not be created or opened.");
  };

  request.onsuccess = function(event) {
    that.db = event.target.result;
    callback();
  }

  request.onupgradeneeded = function(event) {
    that.db = event.target.result;

    // CHECKME: How would I need to check current version to find out what
    // needs adding on each db version?
    var objectStore = db.createObjectStore("time_entry", { keyPath: 'time_entry_id' , autoIncrement: true });
    objectStore.createIndex('date', 'date');

    objectStore.transaction.oncomplete = function(event) {
      console.log("'time_entry' object store created successfully.");
    }
  }

  //   // readTimeEntry: 'TODO',
}

Database.prototype.createTimeEntry = function(timeEntry, callback) {
  var timeEntryStore = this.db.transaction("time_entry", "readwrite").objectStore("time_entry");
  var request = timeEntryStore.add(timeEntry);
  request.onsuccess = function(event) {
    // event.target.result contains the time_entry_id generated by the DB.
    callback(event.target.result);
  }
}

Database.prototype.updateTimeEntry = function(timeEntry, callback) {
  var timeEntryStore = this.db.transaction("time_entry", "readwrite").objectStore("time_entry");
  var request = timeEntryStore.put(timeEntry);
  request.onsuccess = function(event) {
    // event.target.result has the time_entry_id.
    console.log("Time Entry state updated. ID: " + event.target.result);
    if (callback) {
      callback(true);
    }
  };
  request.onerror = function(event) {
    console.log("Error updating Time Entry state. ID: " + event.target.result);
    callback(false);
  }
};

Database.prototype.deleteTimeEntry = function(timeEntryId, callback) {
  var timeEntryStore = this.db.transaction("time_entry", "readwrite").objectStore("time_entry");
  var request = timeEntryStore.delete(timeEntryId);
  request.onsuccess = function(event) {
    console.log("Successfully removed Time Entry. ID: " + timeEntryId);
    if (callback) {
      callback(true);
    }
  };
  request.onerror = function(event) {
    console.log("Error removing Time Entry. ID: " + timeEntryId);
    if (callback) {
      callback(false);
    }
  }
};

// Returns all the existing time entries in the database.
Database.prototype.getAllTimeEntries = function(callback) {
  var timeEntries = [];
  var timeEntryStore = this.db.transaction("time_entry", "readonly").objectStore("time_entry");
  timeEntryStore.openCursor().onsuccess = function(event) {
    var cursor = event.target.result;

    if (cursor) {
      timeEntries.push(cursor.value);
      cursor.continue();
    }
    else {
      callback(timeEntries);
    }
  }
};

// Returns all the existing time entries in the database.
Database.prototype.getAllTimeEntriesSortedByDate = function(callback) {
  var timeEntries = [];
  var timeEntryStore = this.db.transaction("time_entry", "readonly").objectStore("time_entry");
  var index = timeEntryStore.index("date");

  index.openCursor(null, 'prev').onsuccess = function(event) {
    var cursor = event.target.result;

    if (cursor) {
      timeEntries.push(cursor.value);
      cursor.continue();
    }
    else {
      callback(timeEntries);
    }
  }
};