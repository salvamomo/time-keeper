/**
 *  Simple implementation of IndexedDB API to read / write time entries.
 */

/**
 * Defines the Database module for the Time Keeper app.
 *
 * @param name
 *  The name to assign to the database of the database.
 */
function tkDatabase(name) {
  // Set DB version and name.
  const VERSION = 1;
  var db_name = name;

  // DB interaction variables.
  var db = null;
  var request = null;

  /**
   * Initializes the database and returns control to the provided callback.
   *
   * @param callback
   *  The function to call after db has been initialized.
   */
  function init(callback) {
    request = window.indexedDB.open(db_name, VERSION);

    request.onerror = function(event) {
      alert("Database could not be created or opened.");
    };

    request.onsuccess = function(event) {
      this.db = event.target.result;
      callback();
    }.bind(this);

    request.onupgradeneeded = function(event) {
      this.db = event.target.result;

      // CHECKME: How would I need to check current version to find out what
      // needs adding on each db version?
      var objectStore = this.db.createObjectStore("time_entry", { keyPath: 'time_entry_id' , autoIncrement: true });
      objectStore.createIndex('date', 'date');

      objectStore.transaction.oncomplete = function(event) {
        console.log("'time_entry' object store created successfully.");
      }
    }.bind(this);
  }

  /**
   * Add a new TimeEntry to the database.
   *
   * @param timeEntry
   *  The TimeEntry object to add.
   * @param callback
   *  The function to call after the TimeEntry has been added.
   */
  function createTimeEntry(timeEntry, callback) {
    var timeEntryStore = this.db.transaction("time_entry", "readwrite").objectStore("time_entry");
    var request = timeEntryStore.add(timeEntry);

    request.onsuccess = function(event) {
      // event.target.result contains the time_entry_id generated by the DB.
      callback(event.target.result);
    };
    request.onerror = function(event) {
      console.log("Error creating Time Entry: " + event.target.result);
      callback(false);
    }
  }

  /**
   * Updates an existing TimeEntry on the database.
   *
   * @param timeEntry
   *  The TimeEntry to update.
   * @param callback
   *  The function to call after updating the TimeEntry.
   */
  function updateTimeEntry(timeEntry, callback) {
    var timeEntryStore = this.db.transaction("time_entry", "readwrite").objectStore("time_entry");
    var request = timeEntryStore.put(timeEntry);
    request.onsuccess = function(event) {
      // event.target.result has the time_entry_id.
      // console.log("Time Entry state updated. ID: " + event.target.result);
      if (callback) {
        callback(true);
      }
    };
    request.onerror = function(event) {
      console.log("Error updating Time Entry state. ID: " + event.target.result);
      callback(false);
    }
  }

  /**
   * Deletes a TimeEntry from the db.
   *
   * @param timeEntryId
   *  The ID of the TimeEntry to delete.
   * @param callback
   *  The function to call after the TimeEntry has been deleted.
   */
  function deleteTimeEntry(timeEntryId, callback) {
    var timeEntryStore = this.db.transaction("time_entry", "readwrite").objectStore("time_entry");
    var request = timeEntryStore.delete(timeEntryId);
    request.onsuccess = function(event) {
      console.log("Successfully removed Time Entry. ID: " + timeEntryId);
      if (callback) {
        callback(true);
      }
    };
    request.onerror = function(event) {
      console.log("Error removing Time Entry. ID: " + timeEntryId);
      if (callback) {
        callback(false);
      }
    }
  }

  /**
   * Returns all the existing time entries in the database.
   *
   * @param callback
   *  The function to call after time entries have been retrieved.
   */
  function getAllTimeEntries(callback) {
    var timeEntries = [];
    var timeEntryStore = this.db.transaction("time_entry", "readonly").objectStore("time_entry");
    timeEntryStore.openCursor().onsuccess = function(event) {
      var cursor = event.target.result;

      if (cursor) {
        timeEntries.push(cursor.value);
        cursor.continue();
      }
      else {
        callback(timeEntries);
      }
    }
  }

  /**
   * Returns all the existing time entries in the database.
   *
   * @param callback
   *  The function to call after time entries have been retrieved.
   */
  function getAllTimeEntriesSortedByDate(callback) {
    var timeEntries = [];
    var timeEntryStore = this.db.transaction("time_entry", "readonly").objectStore("time_entry");
    var index = timeEntryStore.index("date");

    index.openCursor(null, 'prev').onsuccess = function(event) {
      var cursor = event.target.result;

      if (cursor) {
        timeEntries.push(cursor.value);
        cursor.continue();
      }
      else {
        callback(timeEntries);
      }
    }

  }

  var publicAPI = {
    init: init,
    createTimeEntry: createTimeEntry,
    updateTimeEntry: updateTimeEntry,
    deleteTimeEntry: deleteTimeEntry,
    getAllTimeEntries: getAllTimeEntries,
    getAllTimeEntriesSortedByDate: getAllTimeEntriesSortedByDate
  };

  return publicAPI;
}
